import React, { useEffect, useRef } from 'react';

const EnergyFlowComponent = ({ chronotypeData, className = '' }) => {
  const timelineRef = useRef(null);
  const hourScaleRef = useRef(null);
  const labels = {
    admin: "Admin",
    creative: "Kūryba",
    analytical: "Analizė",
    meetings: "Susitikimai",
    communication: "Komunikacija",
  };

  useEffect(() => {
    if (chronotypeData && chronotypeData.task_windows) {
      generateHorizontalEnergyFlow();
    }
  }, [chronotypeData]);

  const generateHorizontalEnergyFlow = () => {
    const timeline = timelineRef.current;
    const hourScale = hourScaleRef.current;
    
    if (!timeline || !hourScale) return;
    
    // Clear existing content
    timeline.innerHTML = '';
    hourScale.innerHTML = '';
    
    // Find the full time range from all task windows
    const allHours = Object.values(chronotypeData.task_windows).flat();
    if (allHours.length === 0) return;
    
    // const minHour = Math.min(...allHours);
    // const maxHour = Math.max(...allHours);
    const minHour = Math.min(...allHours) - 1;
    const maxHour = Math.max(...allHours) + 1;
    const totalHours = maxHour - minHour + 1;
    
    // Create hour scale
    const hourMarkers = [];
    for (let hour = minHour; hour <= maxHour + 1; hour++) {
      hourMarkers.push(hour);
    }
    
    // Add hour markers and ticks
    hourMarkers.forEach(hour => {
      const position = ((hour - minHour) / totalHours) * 100;
      
      // Hour tick
      const tick = document.createElement('div');
      tick.className = 'hour-tick';
      tick.style.left = `${position}%`;
      hourScale.appendChild(tick);
      
      // Hour label (show every 2-3 hours for cleanliness)
      if (hour === minHour || hour === maxHour + 1 || (hour - minHour) % 3 === 0) {
        const marker = document.createElement('div');
        marker.className = 'hour-marker';
        marker.style.left = `${position}%`;
        marker.textContent = `${hour}:00`;
        hourScale.appendChild(marker);
      }
    });
    
    // Organize task windows into rows to avoid overlaps
    const rows = organizeIntoRows();
    
    // Create energy bar rows
    rows.forEach(row => {
      const rowElement = document.createElement('div');
      rowElement.className = 'energy-row';
      
      row.forEach(({ taskType, ranges }) => {
        ranges.forEach(range => {
          const startPercent = ((range.start - minHour) / totalHours) * 100;
          const widthPercent = ((range.end - range.start + 1) / totalHours) * 100;
          
          const bar = document.createElement('div');
          bar.className = `energy-bar ${taskType}`;
          bar.style.left = `${startPercent}%`;
          bar.style.width = `${widthPercent}%`;
          bar.title = `${range.start}:00-${range.end + 1}:00 • ${labels[taskType]}`;
          
          rowElement.appendChild(bar);
        });
      });
      
      timeline.appendChild(rowElement);
    });
  };

  // Organize overlapping task types into separate rows
  const organizeIntoRows = () => {
    const taskRanges = {};
    
    // Convert each task window to continuous ranges
    Object.entries(chronotypeData.task_windows).forEach(([taskType, hours]) => {
      if (hours.length > 0) {
        taskRanges[taskType] = findContinuousRanges(hours);
      }
    });
    
    const rows = [];
    
    // Place each task type in the first available row
    Object.entries(taskRanges).forEach(([taskType, ranges]) => {
        rows.push([{ taskType, ranges }]);
    });
    
    return rows;
  };
  
  // Find continuous hour ranges
  const findContinuousRanges = (hours) => {
    if (hours.length === 0) return [];
    
    const sortedHours = [...hours].sort((a, b) => a - b);
    const ranges = [];
    let currentRange = { start: sortedHours[0], end: sortedHours[0] };
    
    for (let i = 1; i < sortedHours.length; i++) {
      if (sortedHours[i] === currentRange.end + 1) {
        currentRange.end = sortedHours[i];
      } else {
        ranges.push({ ...currentRange });
        currentRange = { start: sortedHours[i], end: sortedHours[i] };
      }
    }
    
    ranges.push(currentRange);
    return ranges;
  };

  // Don't render if no chronotype data
  if (!chronotypeData || !chronotypeData.task_windows) {
    return null;
  }

  return (
    <div className={`energy-flow-component ${className}`}>
      <div className="energy-flow-title">Tinkamiausias laikas įvairioms užduotims pagal tavo chronotipą*</div>
      
      <div className="energy-timeline" ref={timelineRef}>
        {/* Dynamic bars generated by useEffect */}
      </div>

      <div className="hour-scale" ref={hourScaleRef}>
        {/* Hour markers generated by useEffect */}
      </div>

      <div className="energy-legend">
    {
      Object.entries(labels).map(([key, label]) => (
        <div className="legend-item" key={key}>
          <div className={`legend-dot ${key}`}></div>
          <span className="legend-text">{label}</span>
        </div>
      ))
    }
    <div className="energy-disclaimer">* Šios rekomendacijos remiasi bendrine informacija apie tavo chronotipą ir yra skirtos tau padėti veikti dar produktyviau, o ne sukurti papildomų suvaržymų. Vertink jas kaip galimybes optimizuoti savo dieną - jei tik turi galimybę prisitaikyti savo dienotvarkę pagal savo chronotipą, tačiau žinok: net ir be to vis dar gali veikti produktyviai! </div>
        {/* <div className="legend-item">
          <div className="legend-dot creative"></div>
          <span className="legend-text">Kūryba</span>
        </div>
        <div className="legend-item">
          <div className="legend-dot analytical"></div>
          <span className="legend-text">Analizė</span>
        </div>
        <div className="legend-item">
          <div className="legend-dot meetings"></div>
          <span className="legend-text">Susitikimai</span>
        </div>
        <div className="legend-item">
          <div className="legend-dot admin"></div>
          <span className="legend-text">Admin</span>
        </div>
        <div className="legend-item">
          <div className="legend-dot communication"></div>
          <span className="legend-text">Komunikacija</span>
        </div> */}
      </div>
    </div>
  );
};

export default EnergyFlowComponent;